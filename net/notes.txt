18 July 2021
-------------
Random notes about the project so far. As far as i've come
on this project, i have not started any meaningful thing
distributed systems or on the p2p chat system yet.

I feel like i'm jumping in circles but i know i can do
this project. I am perfectly capable of executing this
project. To stop me from jumping in circles, i'm trying
to define goals for myself anytime i'm working on this
project. Might start to do this for other projects as
well.

So what do i got today?
    - I am trying to give the address resolving, verification
      and parsing layer a consistent interface and i
      also want to complete it.

      - on the address validation things. the plan is to
        give the addresses to the ipaddress module to
        verify if they are addreses, if they are not, i'll
        proceed to call getaddrinfo with the network and
        address provided if that also does not work then
        the address is pretty much not right.

      - for now there will be support for;
        ('tcp', 'udp', 'udp4', 'tcp4') -> IPv4
        ('tcp6', 'udp6') -> IPv6
        More will probably come in the later releases of this
        package or something, there's no plan i'm creating
        this for personal use on my networking projects.

      - the socket.getaddrinfo function has the type
        signature;

        'socket.getaddrinfo(host, port[, family[,\
        socktype[, proto[, flags]]]])'

        and returns a list of tuple of the form;
        (AddrFamily, SockType, Proto, CanonName, SockAddr)

        SockAddr is a tuple and it could be either;
        IPv6 -> (ipaddr, port, flowinfo, scope_id)
        IPv4 -> (ipaddr, port)

    - Next up is figuring out how to type hint instances
      of subclasses of a class without using Unions.

July 21,2021
------------
This becoming more complicated than i thought i was and
its starting to drive me crazy. Today i want to complete
the address parsing part of this package so i can focus
my energy tweaking sockets to deliver gold.

    - get resolve_udp_addr and resolve_tcp_addr to work
      seamlessly and have a common api. Make things simple
      and do not repeat yourself.

July 28, 2021
--------------
Trying to make listen and other function ready for testing.
making the thing work like it is in my head is proving to be
not exactly easy for me right now.

    - when dialing, do you create the socket with the local
     address or the remote address. come to think of it you need
     a socket to connect to.

    - _config_from_addr has been refactored to _config_from_net and
     it does almost the same thing but checks to see if address is
     is valid. if not valid it passes empty strings to host, port.

    - dial, dial_tcp, dial_udp are almost fully functional now.
     not tested yet so can't say if they working or not. but the
     logic pans out soo i guess.

    - listen, listen_udp, listen_tcp and related listening things are
     done now. Nows the time for testing to happen in the package.

July 30, 2021
--------------
I'm having a pretty serious issue with reading and writing from
socket connections at the moment. Couldn't sleep well because
of this problem and here i am at 5 am trying hard to find a solution
to it.

The problem is, because reads are blocking and because right now
my sockets do not know how much data the connection at the other end is
sending into the socket for them to read. They block even after
reading the message.

A specific case is i have a tcp socket listener on localhost, that
listens for connections, if it gets a connection, it reads data
from the connection and then sends the data read back to the client,
an echo server basically. the read socket function is implemented like so,
it uses a while loop to read until it reads an empty byte(b'') then it
breaks and returns the bytes read from the socket. So basically
if it reads the first round of data it goes back to waiting for
another batch to return. But what if there's no other batch?, the
read implementation doesn't know this so it just hangs around waiting
forever for another batch to arrive and not returning the data
it read first. The only way if returns the first data read is if
the clients closes the connection or crashes. This is bad.

I need a way to know the amount of data to be read from the connection,
so that after reading i know where to stop.

Aug 2, 2021
-----------
I've still not started on solving this issue. spent the weekend doing
something fun. Installed debian in a virtual machine, removed the desktop
environment, installed i3wm and now i'm writing this from this lean, 
mean and bad motherfucker :). Now how do we solve this mistery.????


    - i thought about defining a message structure for the sockets. this
      structure will contain the length of the message been recieved or sent
      amidst other things, so when we reading we read till the length of the
      message and stop there. but then i thought, what if we have a python
      server and a go client or the other way around or any other mix of
      languages out there, we will obviously be serving crap and reading
      ourselves so this will plain just not work, i guess. (didnt implement it)

    - this brings us to the second thought i had on this problem. I've been
      hearing alot about non blocking sockets, what their deal?

    - the other idea i had is using timeouts to read the data. Basically
      just like the non blocking sockets. the idea is to set a very short
      timeout on the socket, then try to read so it can return early so
      you quite it.

    - The thing though, python timeouts are exceptions and i basically have
      to handle them as such, but i absolutely do not want that, so i think
      i'll try the non blocking socket first then move on from there.


    - so agenda for today, implement the non blocking logic first then test 
      and move on to do the timeouts and see which one works best.
      the message structure one doesn't seem like a smart idea so i'll put
      that one on hold for now.

    - did a bunch of documentation, refactoring and thinking today and i
      realised who am i to impose timeouts on somebody elses sockets. I have
      to find a better way to prevent the read calls from hanging forever
      and timeout are definitely not the way to go.
      if the non blocking thing doesn't work out i'll have to find a more
      innovative way to do the reads without blocking.
