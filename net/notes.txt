18 July 2021
-------------
Random notes about the project so far. As far as i've come
on this project, i have not started any meaningful thing
distributed systems or on the p2p chat system yet.

I feel like i'm jumping in circles but i know i can do
this project. I am perfectly capable of executing this
project. To stop me from jumping in circles, i'm trying
to define goals for myself anytime i'm working on this
project. Might start to do this for other projects as
well.

So what do i got today?
    - I am trying to give the address resolving, verification
      and parsing layer a consistent interface and i
      also want to complete it.

      - on the address validation things. the plan is to
        give the addresses to the ipaddress module to
        verify if they are addreses, if they are not, i'll
        proceed to call getaddrinfo with the network and
        address provided if that also does not work then
        the address is pretty much not right.

      - for now there will be support for;
        ('tcp', 'udp', 'udp4', 'tcp4') -> IPv4
        ('tcp6', 'udp6') -> IPv6
        More will probably come in the later releases of this
        package or something, there's no plan i'm creating
        this for personal use on my networking projects.

      - the socket.getaddrinfo function has the type
        signature;

        'socket.getaddrinfo(host, port[, family[,\
        socktype[, proto[, flags]]]])'

        and returns a list of tuple of the form;
        (AddrFamily, SockType, Proto, CanonName, SockAddr)

        SockAddr is a tuple and it could be either;
        IPv6 -> (ipaddr, port, flowinfo, scope_id)
        IPv4 -> (ipaddr, port)

    - Next up is figuring out how to type hint instances
      of subclasses of a class without using Unions.

July 21,2021
------------
This becoming more complicated than i thought i was and
its starting to drive me crazy. Today i want to complete
the address parsing part of this package so i can focus
my energy tweaking sockets to deliver gold.

    - get resolve_udp_addr and resolve_tcp_addr to work
      seamlessly and have a common api. Make things simple
      and do not repeat yourself.

July 28, 2021
--------------
Trying to make listen and other function ready for testing.
making the thing work like it is in my head is proving to be
not exactly easy for me right now.

    - when dialing, do you create the socket with the local
     address or the remote address. come to think of it you need
     a socket to connect to.

    - _config_from_addr has been refactored to _config_from_net and
     it does almost the same thing but checks to see if address is
     is valid. if not valid it passes empty strings to host, port.

    - dial, dial_tcp, dial_udp are almost fully functional now.
     not tested yet so can't say if they working or not. but the
     logic pans out soo i guess.

    - listen, listen_udp, listen_tcp and related listening things are
     done now. Nows the time for testing to happen in the package.

July 30, 2021
--------------
I'm having a pretty serious issue with reading and writing from
socket connections at the moment. Couldn't sleep well because
of this problem and here i am at 5 am trying hard to find a solution
to it.

The problem is, because reads are blocking and because right now
my sockets do not know how much data the connection at the other end is
sending into the socket for them to read. They block even after
reading the message.

A specific case is i have a tcp socket listener on localhost, that
listens for connections, if it gets a connection, it reads data
from the connection and then sends the data read back to the client,
an echo server basically. the read socket function is implemented like so,
it uses a while loop to read until it reads an empty byte(b'') then it
breaks and returns the bytes read from the socket. So basically
if it reads the first round of data it goes back to waiting for
another batch to return. But what if there's no other batch?, the
read implementation doesn't know this so it just hangs around waiting
forever for another batch to arrive and not returning the data
it read first. The only way if returns the first data read is if
the clients closes the connection or crashes. This is bad.

I need a way to know the amount of data to be read from the connection,
so that after reading i know where to stop.
